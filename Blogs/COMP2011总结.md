# 写在最前
这篇文章用来总结一些c++中比较基础但是易错的点，毕竟考场手写代码，有些东西还是比较重要的。

# 正文
#### 指针与引用
之前在一篇CSDN里看到，引用代表的是一个变量的别名，而指针是一个新的变量，它指向原来的变量。在作为函数参数传递的同时，这二者没啥太大的区别，同时也都能修饰返回值的类型。
```
int x = 10;
int &y = x;
int* p = &x;

cout << ++(y) << endl;
cout << ++p << endl;

int &y = x*6; //wrong
int &y = 6; //wrong
cout << ++(&y) << endl; //wrong
cout << ++(&x) << endl; //wrong
cout << ++(*p) << endl; //okay

const int &y = 10; //okay
double x = 3.1415926;
const int &z = x;//okay
```
指针自增后内存地址向右移了一位，也就是一个int型所占的内存空间，而引用自增后是变量的值增加了一位。
#### 左值与右值
讲义中的原话是，一个变量有双重角色（左右值），这个角色取决于他出现在哪个地方。
左值代表储存这个变量的内存位置，可读可写，右值代表这个变量的值，只读。
```
int x = 10;

//正确，++x是以左值形式返回
cout << ++++++x << endl;
//错误，x++是以右值形式返回
cout << x++++++ << endl;
//正确，x++只读
cout << x++ << endl;
```
#### 一维数组与指针
之前有说法可以把数组理解为一个指针，其实不是特别恰当的。数组名代表了数组首元素的地址，也就是&a[0]，但是&a时要注意，这个操作相当于取出了存放数组首地址的地址，需要用二级指针来接受，同样的，&a+1也就相当于直接进入了数组的下一行，只不过这一行没有被声明。
#### 指针数组与数组指针
声明char型的指针数组
```
char* a[4] = {"my", "name" ,"is" ,"Eric"};
```
可以看到指针数组当成二维数组在用（字符串数组），当然也可以当成指针的集合。要注意的是二者有些小区别。再申请动态内存时，当成二维数组必须要申请两级动态内存：
```
char** a = new char* [10];
for(int i = 0; i < 10; i++)
    a[i] = new char[10];
```
而当真正用于指针数组时，只需要申请一维动态内存，将数组的每一个元素指向需要指向的地方即可。理解这里我们可以类比声明一个一级指针时，我们可以开辟动态内存给他，让他指向一个新元素。也可以让他直接指向一个原有的内容，或是nullptr。
注意的是指针数组其实就是一个二级指针。

声明一个char型数组指针
```
char (*a)[4];
```
此时这个指针指向数组首地址，及首元素地址。

a是一个二维数组
a+i，a[i]，\*(a+i)，&a[i][0]是等同的。
由a[i]=\*(a+i)得a[i]+j= \*(a+i)+j。由于\*(a+i)+j是二维数组a的i行j列元素的首地址，所以，该元素的值等于\*(\*(a+i)+j)。
想想不难看出，出现了&符号后后面一定要是一个具体的值，不然就是“存放某一地址的地址”，一般是无法确定的。

还有比较重要的是，用new分配给二维数组时，行与行之间的内存不一定是连续的。所以想要连续的内存空间比较好的是把二维数组当成一维数组。
#### const修饰的一二级指针
const修饰指针时会存在几种情况，指针本身固定，指针指向的内容固定，两者都固定，首先要注意的一点是不同的修饰对应的分配动态内存时的操作也是不同的。
```
const int* p;
//常量指针，指向的内容不能变，但可以修改指针的指向。
int* const p;
//指针常量，指向不能变，内容可以变。
const int* const p;
//都不能变
```
事实上一二级指针其实比较类似，不过二级指针会多出一种情况。
```
int* const * p;
```
由于在声明时，相当于在p前加入const，二级指针指向的一级指针是不能被修改的，而其本身，一级最终所指向的整形变量是可以被修改的。

以及在分配动态内存时,此时我们把二级指针当成指针数组来看待.
```
const int** b = new const int* [10];
int ** const c = new int*[10];
```
const修饰的变量必须在声明时赋值，也就导致了在分配动态内存时一定要注意const的位置，因为new也算是一个有返回值的操作。
```
const int** b = new const int* [10];
b[0] = new int [10];
int ** const c = new int*[10];
c[0] = new int [10];
char * const * d = new char *[10];
d[0] = new const char [10]; //not okay
```
#### 声明与定义一级extern关键字
首先需要注意的一点是extern的使用是为了在多个文件中使用同一个变量。而函数其实不需要这个关键字因为函数本身就是默认的全局型。
一般来说在h文件中
```
extern int x;
extern const int y;
```
在cpp文件中
```
int x = 10;
const int y = 10;
```
对于变量来说：
1. 声明：是指出存储类型，并给存储单元指定名称。
2. 定义：是分配内存空间，还可为变量指定初始值。
3. extern关键字：通过使用extern关键字声明变量名，而不是定义它。
~~*摘自知乎*~~

首先一般来说extern变量建议只定义一次，可以声明多次，但是定义多次也不会报错。一般来说声明一次extern后，再再cpp文件里定义，则所有引用h文件的文件不需要再声明与定义就可以使用。
最后这个关键字用作在多个文件里需要修改某一变量，其实类似于const类型变量在h文件里定义就可以了。
#### 类中需要注意的点
1. 首先析构函数可以有多个，但解构函数只能有一个。
2. 当某些函数里参数名与类本身的元素名冲突时，注意使用this指针进行操作。
3. 类默认的类型是private

#### 栈与队列复习
#### 内存分配时的问题
#### 考试中需要注意的点
1. 拿到写出输出的题目时，一定要注意程序的每一部分的输出，main函数中的一定不能漏掉。
2. 同样是描述输出，有些题目其实只是要描述程序干了什么，会输出什么，而不是一个特定的结果
3. 注意对于指针，初始化时一定要注意这个指针有没有给他开动态内存。如果只是初始化了nullptr操作可是完全不一样的。那就需要通过临时变量来分配动态内存，以及更为重要的是及时释放之前的动态内存。
4. 同样是指针，每次拿到指针一定要判断是否为空
5. 链表操作时注意头与尾需要特判的。
6. https://hkust.zoom.us/j/6710018054